# Blosxom Plugin: favorites -*- perl -*-
# Author(s): Steve Schwarz <http://agilitynerd.com/>
# 2006-JAN-15	0.1 initial version.
# Generate unordered HTML list of most visited pages.
# Requires data file generated by the hitcounter plugin.

package favorites;

# -- Configuration --
#
# Name of file holding hash of paths and their current count.
# This file is created by the hitcounter plugin
my $file_name = "$blosxom::plugin_state_dir/hit_stats";

# How many URLs to include in $count
my $num_entries = 10;

# Include hit count with URL?
my $include_counts = 1;		# set to 1 or 0

# Include directories/categories?
my $include_categories = 0;	# set to 1 or 0

# Format of URL in output:
# 1 - only last portion of path in anchor name
# 2 - full path in anchor name
my $anchor_format = 2;	# 1 or 2

# Wrap URL with <a></a>
# 0 - text isn't wrapped with an anchor
# 1 - text is wrapped with an anchor
my $anchor_link = 1;	# 0 or 1

# Array of URL regexps to exclude from the output
my @excludes = ( '^\/$' );	# i.e. exclude root 

# Array of URL regexps to use to group results into <ul>s of $num_entries each:
my @groups = ( '^.*$' );	# default matches all - makes one group
# Here is an example of two top level categories on my site
# Having more than one entry in @groups causes a title to be created
# my @groups = ( '^agility', '^tech' );

# Flavor to use for listed URLs
my $url_flavour = 'html'; # you might want = $blosxom::default_flavor;
# -------------------

use CGI qw/:standard/;

$count = "";	# use $favorites::count to get HTML of paths and counts

sub start {
    # Add/change filters here to not calculate favorities for specific urls/flavours/etc.
    # i.e. A flavour suffix of 'fav' or a CGI param of 'fav' enables this plugin.
    # return 1 if ($blosxom::flavour =~ /fav/ or CGI::param('fav'));
    return 1 if ($blosxom::path_info =~ /Favorites/);
    return 0;	# disabled
}

sub head {
    my($pkg, $path, $body_ref) = @_;
    eval "require Storable";
    if ($@) {
	print STDERR "favorites disabled, Storable package not available"; 
	return 0;
    }
    if (!Storable->can('retrieve')) {
	print STDERR "favorites disabled, Storable::retrieve() not available";
	return 0;
    }

    my $cacheref;
    if (-r $file_name) {
	$cacheref = Storable::retrieve($file_name);
    } else {
	return 1;
    }
    
    # Build a hash of values (hits) to an array of paths for that number of hits.
    # It is possible for multiple paths to have the same number of hits
    my %paths_per_hits;
    while (my ($key, $value) = each %$cacheref) {
	push @{$paths_per_hits{$value}}, $key;
    }
    $count = '';
    # Edit the generated HTML in place here...
    foreach $group (@groups) {
	# You will want to edit this HTML:
	my $group_name = $group;
	$group_name =~ s/\W*(\w+)\W*/$1/;
	$count .= "<h2>Top $num_entries for Category: $group_name </h2>" if ($#groups != 0);
	$count .= "<ul>";

	my $entries = 0;
	# Now iterate hash sorted from highest to lowest.
	foreach $hits ( sort { $b <=> $a } keys %paths_per_hits) {
	    my $ext_path = "";
	    my $url = "";
	    foreach $path (sort @{$paths_per_hits{$hits}}) {
		next unless ($path =~ /$group/);
		my $skip = 0;
		foreach $exclude (@excludes) {
		    chomp($exclude);
		    $skip = 1 and last if ($path =~ /$exclude/);
		}
		next if (1 == $skip);
		# Determine if this is a path (category) or a specific file
		if (-d "$blosxom::datadir/$path") {
		    next if ($include_categories == 0);
		    # directory don't append default flavour
		    $url = $ext_path = "$path";
		} else {
		    # file append default flavour
		    $ext_path = "$path.$url_flavour";
		    $url = $ext_path;
		}

		# Determine anchor name
		my $anchor = "";
		$anchor = File::Basename::basename($ext_path, qr{\..*}) if (1 == $anchor_format); # short anchor
		$anchor = $ext_path if (2 == $anchor_format); # full path anchor

		# Build the HTML sent to the client
		$count .= "<li>";
		$count .= "<a href=\"$blosxom::url/$url\">" if (1 == $anchor_link);
		$count .= "$anchor";
		$count .= " - $hits hits" if ($include_counts == 1);
		$count .= "</a>" if (1 == $anchor_link);
		$count .= "</li>";

		last if (++$entries >= $num_entries);
	    }
	    last if ($entries >= $num_entries);
	}
	$count .= "</ul>";
    }				# foreach group
    return 1;
}
1;

__END__

=head1 LICENSE

this Blosxom Plug-in
Copyright 2006, Steve Schwarz

(This license is the same as Blosxom's)

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
